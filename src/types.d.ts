// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Vite
// plugin that tells the Electron app where to look for the Vite-bundled app code (depending on

// whether you're running in development or production).
declare const MAIN_WINDOW_VITE_DEV_SERVER_URL: string;
declare const MAIN_WINDOW_VITE_NAME: string;

// Preload types
interface ThemeModeContext {
    toggle: () => Promise<boolean>;
    dark: () => Promise<void>;
    light: () => Promise<void>;
    system: () => Promise<boolean>;
    current: () => Promise<"dark" | "light" | "system">;
}

interface ElectronWindow {
    minimize: () => Promise<void>;
    maximize: () => Promise<void>;
    close: () => Promise<void>;
    isMaximized: () => Promise<boolean>;
    onWindowStateChange: (callback: (isMaximized: boolean) => void) => void;
    inspectElement: (x: number, y: number) => Promise<void>;
    isElectron: () => boolean;
}

interface LoadingManagerAPI {
    completeLoading: () => void;
    onAppReady: (callback: () => void) => void;
}

interface VideosAPI {
    selectDirectory: () => Promise<string | null>;
    getVideosFromDirectory: (
        directoryPath: string,
    ) => Promise<import("./types/video").VideoFile[]>;
    getVideoThumbnail: (videoPath: string) => Promise<string>;
    deleteVideoFiles: (videoPaths: string[]) => Promise<{
        success: boolean;
        failed: string[];
        error?: string;
    }>;
    showInFolder: (videoPath: string) => Promise<void>;
    renameFile: (
        oldPath: string,
        newGameName: string,
    ) => Promise<{
        success: boolean;
        oldPath: string;
        newPath?: string;
        error?: string;
    }>;
}

interface VideoEditorAPI {
    getVideoMetadata: (
        videoPath: string,
    ) => Promise<import("./types/video-editor").VideoMetadata | null>;
    exportClip: (
        videoPath: string,
        options: import("./types/video-editor").ExportOptions,
    ) => Promise<{
        success: boolean;
        outputPath?: string;
        error?: string;
    }>;
    copyFileToClipboard: (
        filePath: string,
    ) => Promise<{ success: boolean; error?: string }>;
}

interface AudioWaveformAPI {
    extractWaveform: (
        videoPath: string,
        sampleCount?: number,
        audioTrack?: number,
    ) => Promise<Float32Array | null>;
}

interface DirectoryWatcherAPI {
    watchDirectory: (directoryPath: string) => Promise<boolean>;
    stopWatchingDirectory: (directoryPath: string) => Promise<boolean>;
    onNewVideoFound: (
        callback: (videoFile: import("./types/video").VideoFile) => void,
    ) => () => void;
}

interface GameImage {
    header?: string;
    library_600x900?: string;
    library_hero?: string;
    library_hero_blur?: string;
    logo?: string;
    icon?: string; // The random filename is the icon
}

interface SteamAPI {
    getAllSteamGames: (
        steamDir: string,
    ) => Promise<Record<string, { appid: string; displayName: string }>>;
    getSteamLibraryFolders: (steamDir: string) => Promise<string[]>;
    getAllGameImages: (steamDir: string) => Promise<Record<string, GameImage>>;
    getGameImages: (
        steamDir: string,
        appId: string,
    ) => Promise<GameImage | null>;
}

interface PerformanceAPI {
    getAllData: () => Promise<{
        success: boolean;
        data: Record<string, unknown>;
        error?: string;
    }>;
    getFunctionData: (functionName: string) => Promise<{
        success: boolean;
        data: unknown;
        error?: string;
    }>;
}

declare interface Window {
    themeMode: ThemeModeContext;
    electronWindow: ElectronWindow;
    loadingManager: LoadingManagerAPI;
    appConfig: {
        name: string;
        protocolName: string;
    };
    platform: "web" | "electron";
    videos: VideosAPI;
    videoEditor: VideoEditorAPI;
    audioWaveform: AudioWaveformAPI;
    steam: SteamAPI;
    performanceMonitor: PerformanceAPI;
    directoryWatcher: DirectoryWatcherAPI;
    __REDUX_DEVTOOLS_EXTENSION__?: unknown;
}
